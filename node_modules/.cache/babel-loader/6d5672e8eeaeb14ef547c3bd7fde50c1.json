{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"splitAtTopLevelOnly\", {\n  enumerable: true,\n  get: () => splitAtTopLevelOnly\n});\nconst _regex = /*#__PURE__*/_interopRequireWildcard(require(\"../lib/regex\"));\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\nfunction* splitAtTopLevelOnly(input, separator) {\n  let SPECIALS = new RegExp(`[(){}\\\\[\\\\]${_regex.escape(separator)}]`, \"g\");\n  let depth = 0;\n  let lastIndex = 0;\n  let found = false;\n  let separatorIndex = 0;\n  let separatorStart = 0;\n  let separatorLength = separator.length;\n  // Find all paren-like things & character\n  // And only split on commas if they're top-level\n  for (let match of input.matchAll(SPECIALS)) {\n    let matchesSeparator = match[0] === separator[separatorIndex];\n    let atEndOfSeparator = separatorIndex === separatorLength - 1;\n    let matchesFullSeparator = matchesSeparator && atEndOfSeparator;\n    if (match[0] === \"(\") depth++;\n    if (match[0] === \")\") depth--;\n    if (match[0] === \"[\") depth++;\n    if (match[0] === \"]\") depth--;\n    if (match[0] === \"{\") depth++;\n    if (match[0] === \"}\") depth--;\n    if (matchesSeparator && depth === 0) {\n      if (separatorStart === 0) {\n        separatorStart = match.index;\n      }\n      separatorIndex++;\n    }\n    if (matchesFullSeparator && depth === 0) {\n      found = true;\n      yield input.substring(lastIndex, separatorStart);\n      lastIndex = separatorStart + separatorLength;\n    }\n    if (separatorIndex === separatorLength) {\n      separatorIndex = 0;\n      separatorStart = 0;\n    }\n  }\n  // Provide the last segment of the string if available\n  // Otherwise the whole string since no `char`s were found\n  // This mirrors the behavior of string.split()\n  if (found) {\n    yield input.substring(lastIndex);\n  } else {\n    yield input;\n  }\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","enumerable","get","splitAtTopLevelOnly","_regex","_interopRequireWildcard","require","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","obj","__esModule","default","cache","has","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","input","separator","SPECIALS","RegExp","escape","depth","lastIndex","found","separatorIndex","separatorStart","separatorLength","length","match","matchAll","matchesSeparator","atEndOfSeparator","matchesFullSeparator","index","substring"],"sources":["D:/MyFile/Project/shop-via/node_modules/tailwindcss/lib/util/splitAtTopLevelOnly.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"splitAtTopLevelOnly\", {\n    enumerable: true,\n    get: ()=>splitAtTopLevelOnly\n});\nconst _regex = /*#__PURE__*/ _interopRequireWildcard(require(\"../lib/regex\"));\nfunction _getRequireWildcardCache(nodeInterop) {\n    if (typeof WeakMap !== \"function\") return null;\n    var cacheBabelInterop = new WeakMap();\n    var cacheNodeInterop = new WeakMap();\n    return (_getRequireWildcardCache = function(nodeInterop) {\n        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n    })(nodeInterop);\n}\nfunction _interopRequireWildcard(obj, nodeInterop) {\n    if (!nodeInterop && obj && obj.__esModule) {\n        return obj;\n    }\n    if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n        return {\n            default: obj\n        };\n    }\n    var cache = _getRequireWildcardCache(nodeInterop);\n    if (cache && cache.has(obj)) {\n        return cache.get(obj);\n    }\n    var newObj = {};\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var key in obj){\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n            if (desc && (desc.get || desc.set)) {\n                Object.defineProperty(newObj, key, desc);\n            } else {\n                newObj[key] = obj[key];\n            }\n        }\n    }\n    newObj.default = obj;\n    if (cache) {\n        cache.set(obj, newObj);\n    }\n    return newObj;\n}\nfunction* splitAtTopLevelOnly(input, separator) {\n    let SPECIALS = new RegExp(`[(){}\\\\[\\\\]${_regex.escape(separator)}]`, \"g\");\n    let depth = 0;\n    let lastIndex = 0;\n    let found = false;\n    let separatorIndex = 0;\n    let separatorStart = 0;\n    let separatorLength = separator.length;\n    // Find all paren-like things & character\n    // And only split on commas if they're top-level\n    for (let match of input.matchAll(SPECIALS)){\n        let matchesSeparator = match[0] === separator[separatorIndex];\n        let atEndOfSeparator = separatorIndex === separatorLength - 1;\n        let matchesFullSeparator = matchesSeparator && atEndOfSeparator;\n        if (match[0] === \"(\") depth++;\n        if (match[0] === \")\") depth--;\n        if (match[0] === \"[\") depth++;\n        if (match[0] === \"]\") depth--;\n        if (match[0] === \"{\") depth++;\n        if (match[0] === \"}\") depth--;\n        if (matchesSeparator && depth === 0) {\n            if (separatorStart === 0) {\n                separatorStart = match.index;\n            }\n            separatorIndex++;\n        }\n        if (matchesFullSeparator && depth === 0) {\n            found = true;\n            yield input.substring(lastIndex, separatorStart);\n            lastIndex = separatorStart + separatorLength;\n        }\n        if (separatorIndex === separatorLength) {\n            separatorIndex = 0;\n            separatorStart = 0;\n        }\n    }\n    // Provide the last segment of the string if available\n    // Otherwise the whole string since no `char`s were found\n    // This mirrors the behavior of string.split()\n    if (found) {\n        yield input.substring(lastIndex);\n    } else {\n        yield input;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}