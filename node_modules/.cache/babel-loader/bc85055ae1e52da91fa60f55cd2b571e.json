{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports[\"default\"] = void 0;\nvar _root = _interopRequireDefault(require(\"./selectors/root\"));\nvar _selector = _interopRequireDefault(require(\"./selectors/selector\"));\nvar _className = _interopRequireDefault(require(\"./selectors/className\"));\nvar _comment = _interopRequireDefault(require(\"./selectors/comment\"));\nvar _id = _interopRequireDefault(require(\"./selectors/id\"));\nvar _tag = _interopRequireDefault(require(\"./selectors/tag\"));\nvar _string = _interopRequireDefault(require(\"./selectors/string\"));\nvar _pseudo = _interopRequireDefault(require(\"./selectors/pseudo\"));\nvar _attribute = _interopRequireWildcard(require(\"./selectors/attribute\"));\nvar _universal = _interopRequireDefault(require(\"./selectors/universal\"));\nvar _combinator = _interopRequireDefault(require(\"./selectors/combinator\"));\nvar _nesting = _interopRequireDefault(require(\"./selectors/nesting\"));\nvar _sortAscending = _interopRequireDefault(require(\"./sortAscending\"));\nvar _tokenize = _interopRequireWildcard(require(\"./tokenize\"));\nvar tokens = _interopRequireWildcard(require(\"./tokenTypes\"));\nvar types = _interopRequireWildcard(require(\"./selectors/types\"));\nvar _util = require(\"./util\");\nvar _WHITESPACE_TOKENS, _Object$assign;\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n  _getRequireWildcardCache = function _getRequireWildcardCache() {\n    return cache;\n  };\n  return cache;\n}\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      \"default\": obj\n    };\n  }\n  var cache = _getRequireWildcardCache();\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj[\"default\"] = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\nvar WHITESPACE_TOKENS = (_WHITESPACE_TOKENS = {}, _WHITESPACE_TOKENS[tokens.space] = true, _WHITESPACE_TOKENS[tokens.cr] = true, _WHITESPACE_TOKENS[tokens.feed] = true, _WHITESPACE_TOKENS[tokens.newline] = true, _WHITESPACE_TOKENS[tokens.tab] = true, _WHITESPACE_TOKENS);\nvar WHITESPACE_EQUIV_TOKENS = Object.assign({}, WHITESPACE_TOKENS, (_Object$assign = {}, _Object$assign[tokens.comment] = true, _Object$assign));\nfunction tokenStart(token) {\n  return {\n    line: token[_tokenize.FIELDS.START_LINE],\n    column: token[_tokenize.FIELDS.START_COL]\n  };\n}\nfunction tokenEnd(token) {\n  return {\n    line: token[_tokenize.FIELDS.END_LINE],\n    column: token[_tokenize.FIELDS.END_COL]\n  };\n}\nfunction getSource(startLine, startColumn, endLine, endColumn) {\n  return {\n    start: {\n      line: startLine,\n      column: startColumn\n    },\n    end: {\n      line: endLine,\n      column: endColumn\n    }\n  };\n}\nfunction getTokenSource(token) {\n  return getSource(token[_tokenize.FIELDS.START_LINE], token[_tokenize.FIELDS.START_COL], token[_tokenize.FIELDS.END_LINE], token[_tokenize.FIELDS.END_COL]);\n}\nfunction getTokenSourceSpan(startToken, endToken) {\n  if (!startToken) {\n    return undefined;\n  }\n  return getSource(startToken[_tokenize.FIELDS.START_LINE], startToken[_tokenize.FIELDS.START_COL], endToken[_tokenize.FIELDS.END_LINE], endToken[_tokenize.FIELDS.END_COL]);\n}\nfunction unescapeProp(node, prop) {\n  var value = node[prop];\n  if (typeof value !== \"string\") {\n    return;\n  }\n  if (value.indexOf(\"\\\\\") !== -1) {\n    (0, _util.ensureObject)(node, 'raws');\n    node[prop] = (0, _util.unesc)(value);\n    if (node.raws[prop] === undefined) {\n      node.raws[prop] = value;\n    }\n  }\n  return node;\n}\nfunction indexesOf(array, item) {\n  var i = -1;\n  var indexes = [];\n  while ((i = array.indexOf(item, i + 1)) !== -1) {\n    indexes.push(i);\n  }\n  return indexes;\n}\nfunction uniqs() {\n  var list = Array.prototype.concat.apply([], arguments);\n  return list.filter(function (item, i) {\n    return i === list.indexOf(item);\n  });\n}\nvar Parser = /*#__PURE__*/function () {\n  function Parser(rule, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    this.rule = rule;\n    this.options = Object.assign({\n      lossy: false,\n      safe: false\n    }, options);\n    this.position = 0;\n    this.css = typeof this.rule === 'string' ? this.rule : this.rule.selector;\n    this.tokens = (0, _tokenize[\"default\"])({\n      css: this.css,\n      error: this._errorGenerator(),\n      safe: this.options.safe\n    });\n    var rootSource = getTokenSourceSpan(this.tokens[0], this.tokens[this.tokens.length - 1]);\n    this.root = new _root[\"default\"]({\n      source: rootSource\n    });\n    this.root.errorGenerator = this._errorGenerator();\n    var selector = new _selector[\"default\"]({\n      source: {\n        start: {\n          line: 1,\n          column: 1\n        }\n      }\n    });\n    this.root.append(selector);\n    this.current = selector;\n    this.loop();\n  }\n  var _proto = Parser.prototype;\n  _proto._errorGenerator = function _errorGenerator() {\n    var _this = this;\n    return function (message, errorOptions) {\n      if (typeof _this.rule === 'string') {\n        return new Error(message);\n      }\n      return _this.rule.error(message, errorOptions);\n    };\n  };\n  _proto.attribute = function attribute() {\n    var attr = [];\n    var startingToken = this.currToken;\n    this.position++;\n    while (this.position < this.tokens.length && this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {\n      attr.push(this.currToken);\n      this.position++;\n    }\n    if (this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {\n      return this.expected('closing square bracket', this.currToken[_tokenize.FIELDS.START_POS]);\n    }\n    var len = attr.length;\n    var node = {\n      source: getSource(startingToken[1], startingToken[2], this.currToken[3], this.currToken[4]),\n      sourceIndex: startingToken[_tokenize.FIELDS.START_POS]\n    };\n    if (len === 1 && !~[tokens.word].indexOf(attr[0][_tokenize.FIELDS.TYPE])) {\n      return this.expected('attribute', attr[0][_tokenize.FIELDS.START_POS]);\n    }\n    var pos = 0;\n    var spaceBefore = '';\n    var commentBefore = '';\n    var lastAdded = null;\n    var spaceAfterMeaningfulToken = false;\n    while (pos < len) {\n      var token = attr[pos];\n      var content = this.content(token);\n      var next = attr[pos + 1];\n      switch (token[_tokenize.FIELDS.TYPE]) {\n        case tokens.space:\n          // if (\n          //     len === 1 ||\n          //     pos === 0 && this.content(next) === '|'\n          // ) {\n          //     return this.expected('attribute', token[TOKEN.START_POS], content);\n          // }\n          spaceAfterMeaningfulToken = true;\n          if (this.options.lossy) {\n            break;\n          }\n          if (lastAdded) {\n            (0, _util.ensureObject)(node, 'spaces', lastAdded);\n            var prevContent = node.spaces[lastAdded].after || '';\n            node.spaces[lastAdded].after = prevContent + content;\n            var existingComment = (0, _util.getProp)(node, 'raws', 'spaces', lastAdded, 'after') || null;\n            if (existingComment) {\n              node.raws.spaces[lastAdded].after = existingComment + content;\n            }\n          } else {\n            spaceBefore = spaceBefore + content;\n            commentBefore = commentBefore + content;\n          }\n          break;\n        case tokens.asterisk:\n          if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {\n            node.operator = content;\n            lastAdded = 'operator';\n          } else if ((!node.namespace || lastAdded === \"namespace\" && !spaceAfterMeaningfulToken) && next) {\n            if (spaceBefore) {\n              (0, _util.ensureObject)(node, 'spaces', 'attribute');\n              node.spaces.attribute.before = spaceBefore;\n              spaceBefore = '';\n            }\n            if (commentBefore) {\n              (0, _util.ensureObject)(node, 'raws', 'spaces', 'attribute');\n              node.raws.spaces.attribute.before = spaceBefore;\n              commentBefore = '';\n            }\n            node.namespace = (node.namespace || \"\") + content;\n            var rawValue = (0, _util.getProp)(node, 'raws', 'namespace') || null;\n            if (rawValue) {\n              node.raws.namespace += content;\n            }\n            lastAdded = 'namespace';\n          }\n          spaceAfterMeaningfulToken = false;\n          break;\n        case tokens.dollar:\n          if (lastAdded === \"value\") {\n            var oldRawValue = (0, _util.getProp)(node, 'raws', 'value');\n            node.value += \"$\";\n            if (oldRawValue) {\n              node.raws.value = oldRawValue + \"$\";\n            }\n            break;\n          }\n\n        // Falls through\n\n        case tokens.caret:\n          if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {\n            node.operator = content;\n            lastAdded = 'operator';\n          }\n          spaceAfterMeaningfulToken = false;\n          break;\n        case tokens.combinator:\n          if (content === '~' && next[_tokenize.FIELDS.TYPE] === tokens.equals) {\n            node.operator = content;\n            lastAdded = 'operator';\n          }\n          if (content !== '|') {\n            spaceAfterMeaningfulToken = false;\n            break;\n          }\n          if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {\n            node.operator = content;\n            lastAdded = 'operator';\n          } else if (!node.namespace && !node.attribute) {\n            node.namespace = true;\n          }\n          spaceAfterMeaningfulToken = false;\n          break;\n        case tokens.word:\n          if (next && this.content(next) === '|' && attr[pos + 2] && attr[pos + 2][_tokenize.FIELDS.TYPE] !== tokens.equals &&\n          // this look-ahead probably fails with comment nodes involved.\n          !node.operator && !node.namespace) {\n            node.namespace = content;\n            lastAdded = 'namespace';\n          } else if (!node.attribute || lastAdded === \"attribute\" && !spaceAfterMeaningfulToken) {\n            if (spaceBefore) {\n              (0, _util.ensureObject)(node, 'spaces', 'attribute');\n              node.spaces.attribute.before = spaceBefore;\n              spaceBefore = '';\n            }\n            if (commentBefore) {\n              (0, _util.ensureObject)(node, 'raws', 'spaces', 'attribute');\n              node.raws.spaces.attribute.before = commentBefore;\n              commentBefore = '';\n            }\n            node.attribute = (node.attribute || \"\") + content;\n            var _rawValue = (0, _util.getProp)(node, 'raws', 'attribute') || null;\n            if (_rawValue) {\n              node.raws.attribute += content;\n            }\n            lastAdded = 'attribute';\n          } else if (!node.value && node.value !== \"\" || lastAdded === \"value\" && !spaceAfterMeaningfulToken) {\n            var _unescaped = (0, _util.unesc)(content);\n            var _oldRawValue = (0, _util.getProp)(node, 'raws', 'value') || '';\n            var oldValue = node.value || '';\n            node.value = oldValue + _unescaped;\n            node.quoteMark = null;\n            if (_unescaped !== content || _oldRawValue) {\n              (0, _util.ensureObject)(node, 'raws');\n              node.raws.value = (_oldRawValue || oldValue) + content;\n            }\n            lastAdded = 'value';\n          } else {\n            var insensitive = content === 'i' || content === \"I\";\n            if ((node.value || node.value === '') && (node.quoteMark || spaceAfterMeaningfulToken)) {\n              node.insensitive = insensitive;\n              if (!insensitive || content === \"I\") {\n                (0, _util.ensureObject)(node, 'raws');\n                node.raws.insensitiveFlag = content;\n              }\n              lastAdded = 'insensitive';\n              if (spaceBefore) {\n                (0, _util.ensureObject)(node, 'spaces', 'insensitive');\n                node.spaces.insensitive.before = spaceBefore;\n                spaceBefore = '';\n              }\n              if (commentBefore) {\n                (0, _util.ensureObject)(node, 'raws', 'spaces', 'insensitive');\n                node.raws.spaces.insensitive.before = commentBefore;\n                commentBefore = '';\n              }\n            } else if (node.value || node.value === '') {\n              lastAdded = 'value';\n              node.value += content;\n              if (node.raws.value) {\n                node.raws.value += content;\n              }\n            }\n          }\n          spaceAfterMeaningfulToken = false;\n          break;\n        case tokens.str:\n          if (!node.attribute || !node.operator) {\n            return this.error(\"Expected an attribute followed by an operator preceding the string.\", {\n              index: token[_tokenize.FIELDS.START_POS]\n            });\n          }\n          var _unescapeValue = (0, _attribute.unescapeValue)(content),\n            unescaped = _unescapeValue.unescaped,\n            quoteMark = _unescapeValue.quoteMark;\n          node.value = unescaped;\n          node.quoteMark = quoteMark;\n          lastAdded = 'value';\n          (0, _util.ensureObject)(node, 'raws');\n          node.raws.value = content;\n          spaceAfterMeaningfulToken = false;\n          break;\n        case tokens.equals:\n          if (!node.attribute) {\n            return this.expected('attribute', token[_tokenize.FIELDS.START_POS], content);\n          }\n          if (node.value) {\n            return this.error('Unexpected \"=\" found; an operator was already defined.', {\n              index: token[_tokenize.FIELDS.START_POS]\n            });\n          }\n          node.operator = node.operator ? node.operator + content : content;\n          lastAdded = 'operator';\n          spaceAfterMeaningfulToken = false;\n          break;\n        case tokens.comment:\n          if (lastAdded) {\n            if (spaceAfterMeaningfulToken || next && next[_tokenize.FIELDS.TYPE] === tokens.space || lastAdded === 'insensitive') {\n              var lastComment = (0, _util.getProp)(node, 'spaces', lastAdded, 'after') || '';\n              var rawLastComment = (0, _util.getProp)(node, 'raws', 'spaces', lastAdded, 'after') || lastComment;\n              (0, _util.ensureObject)(node, 'raws', 'spaces', lastAdded);\n              node.raws.spaces[lastAdded].after = rawLastComment + content;\n            } else {\n              var lastValue = node[lastAdded] || '';\n              var rawLastValue = (0, _util.getProp)(node, 'raws', lastAdded) || lastValue;\n              (0, _util.ensureObject)(node, 'raws');\n              node.raws[lastAdded] = rawLastValue + content;\n            }\n          } else {\n            commentBefore = commentBefore + content;\n          }\n          break;\n        default:\n          return this.error(\"Unexpected \\\"\" + content + \"\\\" found.\", {\n            index: token[_tokenize.FIELDS.START_POS]\n          });\n      }\n      pos++;\n    }\n    unescapeProp(node, \"attribute\");\n    unescapeProp(node, \"namespace\");\n    this.newNode(new _attribute[\"default\"](node));\n    this.position++;\n  }\n  /**\n   * return a node containing meaningless garbage up to (but not including) the specified token position.\n   * if the token position is negative, all remaining tokens are consumed.\n   *\n   * This returns an array containing a single string node if all whitespace,\n   * otherwise an array of comment nodes with space before and after.\n   *\n   * These tokens are not added to the current selector, the caller can add them or use them to amend\n   * a previous node's space metadata.\n   *\n   * In lossy mode, this returns only comments.\n   */;\n\n  _proto.parseWhitespaceEquivalentTokens = function parseWhitespaceEquivalentTokens(stopPosition) {\n    if (stopPosition < 0) {\n      stopPosition = this.tokens.length;\n    }\n    var startPosition = this.position;\n    var nodes = [];\n    var space = \"\";\n    var lastComment = undefined;\n    do {\n      if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {\n        if (!this.options.lossy) {\n          space += this.content();\n        }\n      } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.comment) {\n        var spaces = {};\n        if (space) {\n          spaces.before = space;\n          space = \"\";\n        }\n        lastComment = new _comment[\"default\"]({\n          value: this.content(),\n          source: getTokenSource(this.currToken),\n          sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],\n          spaces: spaces\n        });\n        nodes.push(lastComment);\n      }\n    } while (++this.position < stopPosition);\n    if (space) {\n      if (lastComment) {\n        lastComment.spaces.after = space;\n      } else if (!this.options.lossy) {\n        var firstToken = this.tokens[startPosition];\n        var lastToken = this.tokens[this.position - 1];\n        nodes.push(new _string[\"default\"]({\n          value: '',\n          source: getSource(firstToken[_tokenize.FIELDS.START_LINE], firstToken[_tokenize.FIELDS.START_COL], lastToken[_tokenize.FIELDS.END_LINE], lastToken[_tokenize.FIELDS.END_COL]),\n          sourceIndex: firstToken[_tokenize.FIELDS.START_POS],\n          spaces: {\n            before: space,\n            after: ''\n          }\n        }));\n      }\n    }\n    return nodes;\n  }\n  /**\n   * \n   * @param {*} nodes \n   */;\n\n  _proto.convertWhitespaceNodesToSpace = function convertWhitespaceNodesToSpace(nodes, requiredSpace) {\n    var _this2 = this;\n    if (requiredSpace === void 0) {\n      requiredSpace = false;\n    }\n    var space = \"\";\n    var rawSpace = \"\";\n    nodes.forEach(function (n) {\n      var spaceBefore = _this2.lossySpace(n.spaces.before, requiredSpace);\n      var rawSpaceBefore = _this2.lossySpace(n.rawSpaceBefore, requiredSpace);\n      space += spaceBefore + _this2.lossySpace(n.spaces.after, requiredSpace && spaceBefore.length === 0);\n      rawSpace += spaceBefore + n.value + _this2.lossySpace(n.rawSpaceAfter, requiredSpace && rawSpaceBefore.length === 0);\n    });\n    if (rawSpace === space) {\n      rawSpace = undefined;\n    }\n    var result = {\n      space: space,\n      rawSpace: rawSpace\n    };\n    return result;\n  };\n  _proto.isNamedCombinator = function isNamedCombinator(position) {\n    if (position === void 0) {\n      position = this.position;\n    }\n    return this.tokens[position + 0] && this.tokens[position + 0][_tokenize.FIELDS.TYPE] === tokens.slash && this.tokens[position + 1] && this.tokens[position + 1][_tokenize.FIELDS.TYPE] === tokens.word && this.tokens[position + 2] && this.tokens[position + 2][_tokenize.FIELDS.TYPE] === tokens.slash;\n  };\n  _proto.namedCombinator = function namedCombinator() {\n    if (this.isNamedCombinator()) {\n      var nameRaw = this.content(this.tokens[this.position + 1]);\n      var name = (0, _util.unesc)(nameRaw).toLowerCase();\n      var raws = {};\n      if (name !== nameRaw) {\n        raws.value = \"/\" + nameRaw + \"/\";\n      }\n      var node = new _combinator[\"default\"]({\n        value: \"/\" + name + \"/\",\n        source: getSource(this.currToken[_tokenize.FIELDS.START_LINE], this.currToken[_tokenize.FIELDS.START_COL], this.tokens[this.position + 2][_tokenize.FIELDS.END_LINE], this.tokens[this.position + 2][_tokenize.FIELDS.END_COL]),\n        sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],\n        raws: raws\n      });\n      this.position = this.position + 3;\n      return node;\n    } else {\n      this.unexpected();\n    }\n  };\n  _proto.combinator = function combinator() {\n    var _this3 = this;\n    if (this.content() === '|') {\n      return this.namespace();\n    } // We need to decide between a space that's a descendant combinator and meaningless whitespace at the end of a selector.\n\n    var nextSigTokenPos = this.locateNextMeaningfulToken(this.position);\n    if (nextSigTokenPos < 0 || this.tokens[nextSigTokenPos][_tokenize.FIELDS.TYPE] === tokens.comma) {\n      var nodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);\n      if (nodes.length > 0) {\n        var last = this.current.last;\n        if (last) {\n          var _this$convertWhitespa = this.convertWhitespaceNodesToSpace(nodes),\n            space = _this$convertWhitespa.space,\n            rawSpace = _this$convertWhitespa.rawSpace;\n          if (rawSpace !== undefined) {\n            last.rawSpaceAfter += rawSpace;\n          }\n          last.spaces.after += space;\n        } else {\n          nodes.forEach(function (n) {\n            return _this3.newNode(n);\n          });\n        }\n      }\n      return;\n    }\n    var firstToken = this.currToken;\n    var spaceOrDescendantSelectorNodes = undefined;\n    if (nextSigTokenPos > this.position) {\n      spaceOrDescendantSelectorNodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);\n    }\n    var node;\n    if (this.isNamedCombinator()) {\n      node = this.namedCombinator();\n    } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.combinator) {\n      node = new _combinator[\"default\"]({\n        value: this.content(),\n        source: getTokenSource(this.currToken),\n        sourceIndex: this.currToken[_tokenize.FIELDS.START_POS]\n      });\n      this.position++;\n    } else if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {// pass\n    } else if (!spaceOrDescendantSelectorNodes) {\n      this.unexpected();\n    }\n    if (node) {\n      if (spaceOrDescendantSelectorNodes) {\n        var _this$convertWhitespa2 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes),\n          _space = _this$convertWhitespa2.space,\n          _rawSpace = _this$convertWhitespa2.rawSpace;\n        node.spaces.before = _space;\n        node.rawSpaceBefore = _rawSpace;\n      }\n    } else {\n      // descendant combinator\n      var _this$convertWhitespa3 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes, true),\n        _space2 = _this$convertWhitespa3.space,\n        _rawSpace2 = _this$convertWhitespa3.rawSpace;\n      if (!_rawSpace2) {\n        _rawSpace2 = _space2;\n      }\n      var spaces = {};\n      var raws = {\n        spaces: {}\n      };\n      if (_space2.endsWith(' ') && _rawSpace2.endsWith(' ')) {\n        spaces.before = _space2.slice(0, _space2.length - 1);\n        raws.spaces.before = _rawSpace2.slice(0, _rawSpace2.length - 1);\n      } else if (_space2.startsWith(' ') && _rawSpace2.startsWith(' ')) {\n        spaces.after = _space2.slice(1);\n        raws.spaces.after = _rawSpace2.slice(1);\n      } else {\n        raws.value = _rawSpace2;\n      }\n      node = new _combinator[\"default\"]({\n        value: ' ',\n        source: getTokenSourceSpan(firstToken, this.tokens[this.position - 1]),\n        sourceIndex: firstToken[_tokenize.FIELDS.START_POS],\n        spaces: spaces,\n        raws: raws\n      });\n    }\n    if (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.space) {\n      node.spaces.after = this.optionalSpace(this.content());\n      this.position++;\n    }\n    return this.newNode(node);\n  };\n  _proto.comma = function comma() {\n    if (this.position === this.tokens.length - 1) {\n      this.root.trailingComma = true;\n      this.position++;\n      return;\n    }\n    this.current._inferEndPosition();\n    var selector = new _selector[\"default\"]({\n      source: {\n        start: tokenStart(this.tokens[this.position + 1])\n      }\n    });\n    this.current.parent.append(selector);\n    this.current = selector;\n    this.position++;\n  };\n  _proto.comment = function comment() {\n    var current = this.currToken;\n    this.newNode(new _comment[\"default\"]({\n      value: this.content(),\n      source: getTokenSource(current),\n      sourceIndex: current[_tokenize.FIELDS.START_POS]\n    }));\n    this.position++;\n  };\n  _proto.error = function error(message, opts) {\n    throw this.root.error(message, opts);\n  };\n  _proto.missingBackslash = function missingBackslash() {\n    return this.error('Expected a backslash preceding the semicolon.', {\n      index: this.currToken[_tokenize.FIELDS.START_POS]\n    });\n  };\n  _proto.missingParenthesis = function missingParenthesis() {\n    return this.expected('opening parenthesis', this.currToken[_tokenize.FIELDS.START_POS]);\n  };\n  _proto.missingSquareBracket = function missingSquareBracket() {\n    return this.expected('opening square bracket', this.currToken[_tokenize.FIELDS.START_POS]);\n  };\n  _proto.unexpected = function unexpected() {\n    return this.error(\"Unexpected '\" + this.content() + \"'. Escaping special characters with \\\\ may help.\", this.currToken[_tokenize.FIELDS.START_POS]);\n  };\n  _proto.namespace = function namespace() {\n    var before = this.prevToken && this.content(this.prevToken) || true;\n    if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.word) {\n      this.position++;\n      return this.word(before);\n    } else if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.asterisk) {\n      this.position++;\n      return this.universal(before);\n    }\n  };\n  _proto.nesting = function nesting() {\n    if (this.nextToken) {\n      var nextContent = this.content(this.nextToken);\n      if (nextContent === \"|\") {\n        this.position++;\n        return;\n      }\n    }\n    var current = this.currToken;\n    this.newNode(new _nesting[\"default\"]({\n      value: this.content(),\n      source: getTokenSource(current),\n      sourceIndex: current[_tokenize.FIELDS.START_POS]\n    }));\n    this.position++;\n  };\n  _proto.parentheses = function parentheses() {\n    var last = this.current.last;\n    var unbalanced = 1;\n    this.position++;\n    if (last && last.type === types.PSEUDO) {\n      var selector = new _selector[\"default\"]({\n        source: {\n          start: tokenStart(this.tokens[this.position - 1])\n        }\n      });\n      var cache = this.current;\n      last.append(selector);\n      this.current = selector;\n      while (this.position < this.tokens.length && unbalanced) {\n        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {\n          unbalanced++;\n        }\n        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {\n          unbalanced--;\n        }\n        if (unbalanced) {\n          this.parse();\n        } else {\n          this.current.source.end = tokenEnd(this.currToken);\n          this.current.parent.source.end = tokenEnd(this.currToken);\n          this.position++;\n        }\n      }\n      this.current = cache;\n    } else {\n      // I think this case should be an error. It's used to implement a basic parse of media queries\n      // but I don't think it's a good idea.\n      var parenStart = this.currToken;\n      var parenValue = \"(\";\n      var parenEnd;\n      while (this.position < this.tokens.length && unbalanced) {\n        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {\n          unbalanced++;\n        }\n        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {\n          unbalanced--;\n        }\n        parenEnd = this.currToken;\n        parenValue += this.parseParenthesisToken(this.currToken);\n        this.position++;\n      }\n      if (last) {\n        last.appendToPropertyAndEscape(\"value\", parenValue, parenValue);\n      } else {\n        this.newNode(new _string[\"default\"]({\n          value: parenValue,\n          source: getSource(parenStart[_tokenize.FIELDS.START_LINE], parenStart[_tokenize.FIELDS.START_COL], parenEnd[_tokenize.FIELDS.END_LINE], parenEnd[_tokenize.FIELDS.END_COL]),\n          sourceIndex: parenStart[_tokenize.FIELDS.START_POS]\n        }));\n      }\n    }\n    if (unbalanced) {\n      return this.expected('closing parenthesis', this.currToken[_tokenize.FIELDS.START_POS]);\n    }\n  };\n  _proto.pseudo = function pseudo() {\n    var _this4 = this;\n    var pseudoStr = '';\n    var startingToken = this.currToken;\n    while (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.colon) {\n      pseudoStr += this.content();\n      this.position++;\n    }\n    if (!this.currToken) {\n      return this.expected(['pseudo-class', 'pseudo-element'], this.position - 1);\n    }\n    if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.word) {\n      this.splitWord(false, function (first, length) {\n        pseudoStr += first;\n        _this4.newNode(new _pseudo[\"default\"]({\n          value: pseudoStr,\n          source: getTokenSourceSpan(startingToken, _this4.currToken),\n          sourceIndex: startingToken[_tokenize.FIELDS.START_POS]\n        }));\n        if (length > 1 && _this4.nextToken && _this4.nextToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {\n          _this4.error('Misplaced parenthesis.', {\n            index: _this4.nextToken[_tokenize.FIELDS.START_POS]\n          });\n        }\n      });\n    } else {\n      return this.expected(['pseudo-class', 'pseudo-element'], this.currToken[_tokenize.FIELDS.START_POS]);\n    }\n  };\n  _proto.space = function space() {\n    var content = this.content(); // Handle space before and after the selector\n\n    if (this.position === 0 || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis || this.current.nodes.every(function (node) {\n      return node.type === 'comment';\n    })) {\n      this.spaces = this.optionalSpace(content);\n      this.position++;\n    } else if (this.position === this.tokens.length - 1 || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {\n      this.current.last.spaces.after = this.optionalSpace(content);\n      this.position++;\n    } else {\n      this.combinator();\n    }\n  };\n  _proto.string = function string() {\n    var current = this.currToken;\n    this.newNode(new _string[\"default\"]({\n      value: this.content(),\n      source: getTokenSource(current),\n      sourceIndex: current[_tokenize.FIELDS.START_POS]\n    }));\n    this.position++;\n  };\n  _proto.universal = function universal(namespace) {\n    var nextToken = this.nextToken;\n    if (nextToken && this.content(nextToken) === '|') {\n      this.position++;\n      return this.namespace();\n    }\n    var current = this.currToken;\n    this.newNode(new _universal[\"default\"]({\n      value: this.content(),\n      source: getTokenSource(current),\n      sourceIndex: current[_tokenize.FIELDS.START_POS]\n    }), namespace);\n    this.position++;\n  };\n  _proto.splitWord = function splitWord(namespace, firstCallback) {\n    var _this5 = this;\n    var nextToken = this.nextToken;\n    var word = this.content();\n    while (nextToken && ~[tokens.dollar, tokens.caret, tokens.equals, tokens.word].indexOf(nextToken[_tokenize.FIELDS.TYPE])) {\n      this.position++;\n      var current = this.content();\n      word += current;\n      if (current.lastIndexOf('\\\\') === current.length - 1) {\n        var next = this.nextToken;\n        if (next && next[_tokenize.FIELDS.TYPE] === tokens.space) {\n          word += this.requiredSpace(this.content(next));\n          this.position++;\n        }\n      }\n      nextToken = this.nextToken;\n    }\n    var hasClass = indexesOf(word, '.').filter(function (i) {\n      // Allow escaped dot within class name\n      var escapedDot = word[i - 1] === '\\\\'; // Allow decimal numbers percent in @keyframes\n\n      var isKeyframesPercent = /^\\d+\\.\\d+%$/.test(word);\n      return !escapedDot && !isKeyframesPercent;\n    });\n    var hasId = indexesOf(word, '#').filter(function (i) {\n      return word[i - 1] !== '\\\\';\n    }); // Eliminate Sass interpolations from the list of id indexes\n\n    var interpolations = indexesOf(word, '#{');\n    if (interpolations.length) {\n      hasId = hasId.filter(function (hashIndex) {\n        return !~interpolations.indexOf(hashIndex);\n      });\n    }\n    var indices = (0, _sortAscending[\"default\"])(uniqs([0].concat(hasClass, hasId)));\n    indices.forEach(function (ind, i) {\n      var index = indices[i + 1] || word.length;\n      var value = word.slice(ind, index);\n      if (i === 0 && firstCallback) {\n        return firstCallback.call(_this5, value, indices.length);\n      }\n      var node;\n      var current = _this5.currToken;\n      var sourceIndex = current[_tokenize.FIELDS.START_POS] + indices[i];\n      var source = getSource(current[1], current[2] + ind, current[3], current[2] + (index - 1));\n      if (~hasClass.indexOf(ind)) {\n        var classNameOpts = {\n          value: value.slice(1),\n          source: source,\n          sourceIndex: sourceIndex\n        };\n        node = new _className[\"default\"](unescapeProp(classNameOpts, \"value\"));\n      } else if (~hasId.indexOf(ind)) {\n        var idOpts = {\n          value: value.slice(1),\n          source: source,\n          sourceIndex: sourceIndex\n        };\n        node = new _id[\"default\"](unescapeProp(idOpts, \"value\"));\n      } else {\n        var tagOpts = {\n          value: value,\n          source: source,\n          sourceIndex: sourceIndex\n        };\n        unescapeProp(tagOpts, \"value\");\n        node = new _tag[\"default\"](tagOpts);\n      }\n      _this5.newNode(node, namespace); // Ensure that the namespace is used only once\n\n      namespace = null;\n    });\n    this.position++;\n  };\n  _proto.word = function word(namespace) {\n    var nextToken = this.nextToken;\n    if (nextToken && this.content(nextToken) === '|') {\n      this.position++;\n      return this.namespace();\n    }\n    return this.splitWord(namespace);\n  };\n  _proto.loop = function loop() {\n    while (this.position < this.tokens.length) {\n      this.parse(true);\n    }\n    this.current._inferEndPosition();\n    return this.root;\n  };\n  _proto.parse = function parse(throwOnParenthesis) {\n    switch (this.currToken[_tokenize.FIELDS.TYPE]) {\n      case tokens.space:\n        this.space();\n        break;\n      case tokens.comment:\n        this.comment();\n        break;\n      case tokens.openParenthesis:\n        this.parentheses();\n        break;\n      case tokens.closeParenthesis:\n        if (throwOnParenthesis) {\n          this.missingParenthesis();\n        }\n        break;\n      case tokens.openSquare:\n        this.attribute();\n        break;\n      case tokens.dollar:\n      case tokens.caret:\n      case tokens.equals:\n      case tokens.word:\n        this.word();\n        break;\n      case tokens.colon:\n        this.pseudo();\n        break;\n      case tokens.comma:\n        this.comma();\n        break;\n      case tokens.asterisk:\n        this.universal();\n        break;\n      case tokens.ampersand:\n        this.nesting();\n        break;\n      case tokens.slash:\n      case tokens.combinator:\n        this.combinator();\n        break;\n      case tokens.str:\n        this.string();\n        break;\n      // These cases throw; no break needed.\n\n      case tokens.closeSquare:\n        this.missingSquareBracket();\n      case tokens.semicolon:\n        this.missingBackslash();\n      default:\n        this.unexpected();\n    }\n  }\n  /**\n   * Helpers\n   */;\n\n  _proto.expected = function expected(description, index, found) {\n    if (Array.isArray(description)) {\n      var last = description.pop();\n      description = description.join(', ') + \" or \" + last;\n    }\n    var an = /^[aeiou]/.test(description[0]) ? 'an' : 'a';\n    if (!found) {\n      return this.error(\"Expected \" + an + \" \" + description + \".\", {\n        index: index\n      });\n    }\n    return this.error(\"Expected \" + an + \" \" + description + \", found \\\"\" + found + \"\\\" instead.\", {\n      index: index\n    });\n  };\n  _proto.requiredSpace = function requiredSpace(space) {\n    return this.options.lossy ? ' ' : space;\n  };\n  _proto.optionalSpace = function optionalSpace(space) {\n    return this.options.lossy ? '' : space;\n  };\n  _proto.lossySpace = function lossySpace(space, required) {\n    if (this.options.lossy) {\n      return required ? ' ' : '';\n    } else {\n      return space;\n    }\n  };\n  _proto.parseParenthesisToken = function parseParenthesisToken(token) {\n    var content = this.content(token);\n    if (token[_tokenize.FIELDS.TYPE] === tokens.space) {\n      return this.requiredSpace(content);\n    } else {\n      return content;\n    }\n  };\n  _proto.newNode = function newNode(node, namespace) {\n    if (namespace) {\n      if (/^ +$/.test(namespace)) {\n        if (!this.options.lossy) {\n          this.spaces = (this.spaces || '') + namespace;\n        }\n        namespace = true;\n      }\n      node.namespace = namespace;\n      unescapeProp(node, \"namespace\");\n    }\n    if (this.spaces) {\n      node.spaces.before = this.spaces;\n      this.spaces = '';\n    }\n    return this.current.append(node);\n  };\n  _proto.content = function content(token) {\n    if (token === void 0) {\n      token = this.currToken;\n    }\n    return this.css.slice(token[_tokenize.FIELDS.START_POS], token[_tokenize.FIELDS.END_POS]);\n  };\n\n  /**\n   * returns the index of the next non-whitespace, non-comment token.\n   * returns -1 if no meaningful token is found.\n   */\n  _proto.locateNextMeaningfulToken = function locateNextMeaningfulToken(startPosition) {\n    if (startPosition === void 0) {\n      startPosition = this.position + 1;\n    }\n    var searchPosition = startPosition;\n    while (searchPosition < this.tokens.length) {\n      if (WHITESPACE_EQUIV_TOKENS[this.tokens[searchPosition][_tokenize.FIELDS.TYPE]]) {\n        searchPosition++;\n        continue;\n      } else {\n        return searchPosition;\n      }\n    }\n    return -1;\n  };\n  _createClass(Parser, [{\n    key: \"currToken\",\n    get: function get() {\n      return this.tokens[this.position];\n    }\n  }, {\n    key: \"nextToken\",\n    get: function get() {\n      return this.tokens[this.position + 1];\n    }\n  }, {\n    key: \"prevToken\",\n    get: function get() {\n      return this.tokens[this.position - 1];\n    }\n  }]);\n  return Parser;\n}();\nexports[\"default\"] = Parser;\nmodule.exports = exports.default;","map":{"version":3,"names":["exports","__esModule","_root","_interopRequireDefault","require","_selector","_className","_comment","_id","_tag","_string","_pseudo","_attribute","_interopRequireWildcard","_universal","_combinator","_nesting","_sortAscending","_tokenize","tokens","types","_util","_WHITESPACE_TOKENS","_Object$assign","_getRequireWildcardCache","WeakMap","cache","obj","has","get","newObj","hasPropertyDescriptor","Object","defineProperty","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","_createClass","Constructor","protoProps","staticProps","WHITESPACE_TOKENS","space","cr","feed","newline","tab","WHITESPACE_EQUIV_TOKENS","assign","comment","tokenStart","token","line","FIELDS","START_LINE","column","START_COL","tokenEnd","END_LINE","END_COL","getSource","startLine","startColumn","endLine","endColumn","start","end","getTokenSource","getTokenSourceSpan","startToken","endToken","undefined","unescapeProp","node","prop","value","indexOf","ensureObject","unesc","raws","indexesOf","array","item","indexes","push","uniqs","list","Array","concat","apply","arguments","filter","Parser","rule","options","lossy","safe","position","css","selector","error","_errorGenerator","rootSource","root","source","errorGenerator","append","current","loop","_proto","_this","message","errorOptions","Error","attribute","attr","startingToken","currToken","TYPE","closeSquare","expected","START_POS","len","sourceIndex","word","pos","spaceBefore","commentBefore","lastAdded","spaceAfterMeaningfulToken","content","next","prevContent","spaces","after","existingComment","getProp","asterisk","equals","operator","namespace","before","rawValue","dollar","oldRawValue","caret","combinator","_rawValue","_unescaped","_oldRawValue","oldValue","quoteMark","insensitive","insensitiveFlag","str","index","_unescapeValue","unescapeValue","unescaped","lastComment","rawLastComment","lastValue","rawLastValue","newNode","parseWhitespaceEquivalentTokens","stopPosition","startPosition","nodes","firstToken","lastToken","convertWhitespaceNodesToSpace","requiredSpace","_this2","rawSpace","forEach","n","lossySpace","rawSpaceBefore","rawSpaceAfter","result","isNamedCombinator","slash","namedCombinator","nameRaw","name","toLowerCase","unexpected","_this3","nextSigTokenPos","locateNextMeaningfulToken","comma","last","_this$convertWhitespa","spaceOrDescendantSelectorNodes","_this$convertWhitespa2","_space","_rawSpace","_this$convertWhitespa3","_space2","_rawSpace2","endsWith","slice","startsWith","optionalSpace","trailingComma","_inferEndPosition","parent","opts","missingBackslash","missingParenthesis","missingSquareBracket","prevToken","nextToken","universal","nesting","nextContent","parentheses","unbalanced","type","PSEUDO","openParenthesis","closeParenthesis","parse","parenStart","parenValue","parenEnd","parseParenthesisToken","appendToPropertyAndEscape","pseudo","_this4","pseudoStr","colon","splitWord","first","every","string","firstCallback","_this5","lastIndexOf","hasClass","escapedDot","isKeyframesPercent","test","hasId","interpolations","hashIndex","indices","ind","classNameOpts","idOpts","tagOpts","throwOnParenthesis","openSquare","ampersand","semicolon","description","found","isArray","pop","join","an","required","END_POS","searchPosition","module","default"],"sources":["D:/MyFile/Project/shop-via/node_modules/postcss-selector-parser/dist/parser.js"],"sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\nexports[\"default\"] = void 0;\n\nvar _root = _interopRequireDefault(require(\"./selectors/root\"));\n\nvar _selector = _interopRequireDefault(require(\"./selectors/selector\"));\n\nvar _className = _interopRequireDefault(require(\"./selectors/className\"));\n\nvar _comment = _interopRequireDefault(require(\"./selectors/comment\"));\n\nvar _id = _interopRequireDefault(require(\"./selectors/id\"));\n\nvar _tag = _interopRequireDefault(require(\"./selectors/tag\"));\n\nvar _string = _interopRequireDefault(require(\"./selectors/string\"));\n\nvar _pseudo = _interopRequireDefault(require(\"./selectors/pseudo\"));\n\nvar _attribute = _interopRequireWildcard(require(\"./selectors/attribute\"));\n\nvar _universal = _interopRequireDefault(require(\"./selectors/universal\"));\n\nvar _combinator = _interopRequireDefault(require(\"./selectors/combinator\"));\n\nvar _nesting = _interopRequireDefault(require(\"./selectors/nesting\"));\n\nvar _sortAscending = _interopRequireDefault(require(\"./sortAscending\"));\n\nvar _tokenize = _interopRequireWildcard(require(\"./tokenize\"));\n\nvar tokens = _interopRequireWildcard(require(\"./tokenTypes\"));\n\nvar types = _interopRequireWildcard(require(\"./selectors/types\"));\n\nvar _util = require(\"./util\");\n\nvar _WHITESPACE_TOKENS, _Object$assign;\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { \"default\": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj[\"default\"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar WHITESPACE_TOKENS = (_WHITESPACE_TOKENS = {}, _WHITESPACE_TOKENS[tokens.space] = true, _WHITESPACE_TOKENS[tokens.cr] = true, _WHITESPACE_TOKENS[tokens.feed] = true, _WHITESPACE_TOKENS[tokens.newline] = true, _WHITESPACE_TOKENS[tokens.tab] = true, _WHITESPACE_TOKENS);\nvar WHITESPACE_EQUIV_TOKENS = Object.assign({}, WHITESPACE_TOKENS, (_Object$assign = {}, _Object$assign[tokens.comment] = true, _Object$assign));\n\nfunction tokenStart(token) {\n  return {\n    line: token[_tokenize.FIELDS.START_LINE],\n    column: token[_tokenize.FIELDS.START_COL]\n  };\n}\n\nfunction tokenEnd(token) {\n  return {\n    line: token[_tokenize.FIELDS.END_LINE],\n    column: token[_tokenize.FIELDS.END_COL]\n  };\n}\n\nfunction getSource(startLine, startColumn, endLine, endColumn) {\n  return {\n    start: {\n      line: startLine,\n      column: startColumn\n    },\n    end: {\n      line: endLine,\n      column: endColumn\n    }\n  };\n}\n\nfunction getTokenSource(token) {\n  return getSource(token[_tokenize.FIELDS.START_LINE], token[_tokenize.FIELDS.START_COL], token[_tokenize.FIELDS.END_LINE], token[_tokenize.FIELDS.END_COL]);\n}\n\nfunction getTokenSourceSpan(startToken, endToken) {\n  if (!startToken) {\n    return undefined;\n  }\n\n  return getSource(startToken[_tokenize.FIELDS.START_LINE], startToken[_tokenize.FIELDS.START_COL], endToken[_tokenize.FIELDS.END_LINE], endToken[_tokenize.FIELDS.END_COL]);\n}\n\nfunction unescapeProp(node, prop) {\n  var value = node[prop];\n\n  if (typeof value !== \"string\") {\n    return;\n  }\n\n  if (value.indexOf(\"\\\\\") !== -1) {\n    (0, _util.ensureObject)(node, 'raws');\n    node[prop] = (0, _util.unesc)(value);\n\n    if (node.raws[prop] === undefined) {\n      node.raws[prop] = value;\n    }\n  }\n\n  return node;\n}\n\nfunction indexesOf(array, item) {\n  var i = -1;\n  var indexes = [];\n\n  while ((i = array.indexOf(item, i + 1)) !== -1) {\n    indexes.push(i);\n  }\n\n  return indexes;\n}\n\nfunction uniqs() {\n  var list = Array.prototype.concat.apply([], arguments);\n  return list.filter(function (item, i) {\n    return i === list.indexOf(item);\n  });\n}\n\nvar Parser = /*#__PURE__*/function () {\n  function Parser(rule, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    this.rule = rule;\n    this.options = Object.assign({\n      lossy: false,\n      safe: false\n    }, options);\n    this.position = 0;\n    this.css = typeof this.rule === 'string' ? this.rule : this.rule.selector;\n    this.tokens = (0, _tokenize[\"default\"])({\n      css: this.css,\n      error: this._errorGenerator(),\n      safe: this.options.safe\n    });\n    var rootSource = getTokenSourceSpan(this.tokens[0], this.tokens[this.tokens.length - 1]);\n    this.root = new _root[\"default\"]({\n      source: rootSource\n    });\n    this.root.errorGenerator = this._errorGenerator();\n    var selector = new _selector[\"default\"]({\n      source: {\n        start: {\n          line: 1,\n          column: 1\n        }\n      }\n    });\n    this.root.append(selector);\n    this.current = selector;\n    this.loop();\n  }\n\n  var _proto = Parser.prototype;\n\n  _proto._errorGenerator = function _errorGenerator() {\n    var _this = this;\n\n    return function (message, errorOptions) {\n      if (typeof _this.rule === 'string') {\n        return new Error(message);\n      }\n\n      return _this.rule.error(message, errorOptions);\n    };\n  };\n\n  _proto.attribute = function attribute() {\n    var attr = [];\n    var startingToken = this.currToken;\n    this.position++;\n\n    while (this.position < this.tokens.length && this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {\n      attr.push(this.currToken);\n      this.position++;\n    }\n\n    if (this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {\n      return this.expected('closing square bracket', this.currToken[_tokenize.FIELDS.START_POS]);\n    }\n\n    var len = attr.length;\n    var node = {\n      source: getSource(startingToken[1], startingToken[2], this.currToken[3], this.currToken[4]),\n      sourceIndex: startingToken[_tokenize.FIELDS.START_POS]\n    };\n\n    if (len === 1 && !~[tokens.word].indexOf(attr[0][_tokenize.FIELDS.TYPE])) {\n      return this.expected('attribute', attr[0][_tokenize.FIELDS.START_POS]);\n    }\n\n    var pos = 0;\n    var spaceBefore = '';\n    var commentBefore = '';\n    var lastAdded = null;\n    var spaceAfterMeaningfulToken = false;\n\n    while (pos < len) {\n      var token = attr[pos];\n      var content = this.content(token);\n      var next = attr[pos + 1];\n\n      switch (token[_tokenize.FIELDS.TYPE]) {\n        case tokens.space:\n          // if (\n          //     len === 1 ||\n          //     pos === 0 && this.content(next) === '|'\n          // ) {\n          //     return this.expected('attribute', token[TOKEN.START_POS], content);\n          // }\n          spaceAfterMeaningfulToken = true;\n\n          if (this.options.lossy) {\n            break;\n          }\n\n          if (lastAdded) {\n            (0, _util.ensureObject)(node, 'spaces', lastAdded);\n            var prevContent = node.spaces[lastAdded].after || '';\n            node.spaces[lastAdded].after = prevContent + content;\n            var existingComment = (0, _util.getProp)(node, 'raws', 'spaces', lastAdded, 'after') || null;\n\n            if (existingComment) {\n              node.raws.spaces[lastAdded].after = existingComment + content;\n            }\n          } else {\n            spaceBefore = spaceBefore + content;\n            commentBefore = commentBefore + content;\n          }\n\n          break;\n\n        case tokens.asterisk:\n          if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {\n            node.operator = content;\n            lastAdded = 'operator';\n          } else if ((!node.namespace || lastAdded === \"namespace\" && !spaceAfterMeaningfulToken) && next) {\n            if (spaceBefore) {\n              (0, _util.ensureObject)(node, 'spaces', 'attribute');\n              node.spaces.attribute.before = spaceBefore;\n              spaceBefore = '';\n            }\n\n            if (commentBefore) {\n              (0, _util.ensureObject)(node, 'raws', 'spaces', 'attribute');\n              node.raws.spaces.attribute.before = spaceBefore;\n              commentBefore = '';\n            }\n\n            node.namespace = (node.namespace || \"\") + content;\n            var rawValue = (0, _util.getProp)(node, 'raws', 'namespace') || null;\n\n            if (rawValue) {\n              node.raws.namespace += content;\n            }\n\n            lastAdded = 'namespace';\n          }\n\n          spaceAfterMeaningfulToken = false;\n          break;\n\n        case tokens.dollar:\n          if (lastAdded === \"value\") {\n            var oldRawValue = (0, _util.getProp)(node, 'raws', 'value');\n            node.value += \"$\";\n\n            if (oldRawValue) {\n              node.raws.value = oldRawValue + \"$\";\n            }\n\n            break;\n          }\n\n        // Falls through\n\n        case tokens.caret:\n          if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {\n            node.operator = content;\n            lastAdded = 'operator';\n          }\n\n          spaceAfterMeaningfulToken = false;\n          break;\n\n        case tokens.combinator:\n          if (content === '~' && next[_tokenize.FIELDS.TYPE] === tokens.equals) {\n            node.operator = content;\n            lastAdded = 'operator';\n          }\n\n          if (content !== '|') {\n            spaceAfterMeaningfulToken = false;\n            break;\n          }\n\n          if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {\n            node.operator = content;\n            lastAdded = 'operator';\n          } else if (!node.namespace && !node.attribute) {\n            node.namespace = true;\n          }\n\n          spaceAfterMeaningfulToken = false;\n          break;\n\n        case tokens.word:\n          if (next && this.content(next) === '|' && attr[pos + 2] && attr[pos + 2][_tokenize.FIELDS.TYPE] !== tokens.equals && // this look-ahead probably fails with comment nodes involved.\n          !node.operator && !node.namespace) {\n            node.namespace = content;\n            lastAdded = 'namespace';\n          } else if (!node.attribute || lastAdded === \"attribute\" && !spaceAfterMeaningfulToken) {\n            if (spaceBefore) {\n              (0, _util.ensureObject)(node, 'spaces', 'attribute');\n              node.spaces.attribute.before = spaceBefore;\n              spaceBefore = '';\n            }\n\n            if (commentBefore) {\n              (0, _util.ensureObject)(node, 'raws', 'spaces', 'attribute');\n              node.raws.spaces.attribute.before = commentBefore;\n              commentBefore = '';\n            }\n\n            node.attribute = (node.attribute || \"\") + content;\n\n            var _rawValue = (0, _util.getProp)(node, 'raws', 'attribute') || null;\n\n            if (_rawValue) {\n              node.raws.attribute += content;\n            }\n\n            lastAdded = 'attribute';\n          } else if (!node.value && node.value !== \"\" || lastAdded === \"value\" && !spaceAfterMeaningfulToken) {\n            var _unescaped = (0, _util.unesc)(content);\n\n            var _oldRawValue = (0, _util.getProp)(node, 'raws', 'value') || '';\n\n            var oldValue = node.value || '';\n            node.value = oldValue + _unescaped;\n            node.quoteMark = null;\n\n            if (_unescaped !== content || _oldRawValue) {\n              (0, _util.ensureObject)(node, 'raws');\n              node.raws.value = (_oldRawValue || oldValue) + content;\n            }\n\n            lastAdded = 'value';\n          } else {\n            var insensitive = content === 'i' || content === \"I\";\n\n            if ((node.value || node.value === '') && (node.quoteMark || spaceAfterMeaningfulToken)) {\n              node.insensitive = insensitive;\n\n              if (!insensitive || content === \"I\") {\n                (0, _util.ensureObject)(node, 'raws');\n                node.raws.insensitiveFlag = content;\n              }\n\n              lastAdded = 'insensitive';\n\n              if (spaceBefore) {\n                (0, _util.ensureObject)(node, 'spaces', 'insensitive');\n                node.spaces.insensitive.before = spaceBefore;\n                spaceBefore = '';\n              }\n\n              if (commentBefore) {\n                (0, _util.ensureObject)(node, 'raws', 'spaces', 'insensitive');\n                node.raws.spaces.insensitive.before = commentBefore;\n                commentBefore = '';\n              }\n            } else if (node.value || node.value === '') {\n              lastAdded = 'value';\n              node.value += content;\n\n              if (node.raws.value) {\n                node.raws.value += content;\n              }\n            }\n          }\n\n          spaceAfterMeaningfulToken = false;\n          break;\n\n        case tokens.str:\n          if (!node.attribute || !node.operator) {\n            return this.error(\"Expected an attribute followed by an operator preceding the string.\", {\n              index: token[_tokenize.FIELDS.START_POS]\n            });\n          }\n\n          var _unescapeValue = (0, _attribute.unescapeValue)(content),\n              unescaped = _unescapeValue.unescaped,\n              quoteMark = _unescapeValue.quoteMark;\n\n          node.value = unescaped;\n          node.quoteMark = quoteMark;\n          lastAdded = 'value';\n          (0, _util.ensureObject)(node, 'raws');\n          node.raws.value = content;\n          spaceAfterMeaningfulToken = false;\n          break;\n\n        case tokens.equals:\n          if (!node.attribute) {\n            return this.expected('attribute', token[_tokenize.FIELDS.START_POS], content);\n          }\n\n          if (node.value) {\n            return this.error('Unexpected \"=\" found; an operator was already defined.', {\n              index: token[_tokenize.FIELDS.START_POS]\n            });\n          }\n\n          node.operator = node.operator ? node.operator + content : content;\n          lastAdded = 'operator';\n          spaceAfterMeaningfulToken = false;\n          break;\n\n        case tokens.comment:\n          if (lastAdded) {\n            if (spaceAfterMeaningfulToken || next && next[_tokenize.FIELDS.TYPE] === tokens.space || lastAdded === 'insensitive') {\n              var lastComment = (0, _util.getProp)(node, 'spaces', lastAdded, 'after') || '';\n              var rawLastComment = (0, _util.getProp)(node, 'raws', 'spaces', lastAdded, 'after') || lastComment;\n              (0, _util.ensureObject)(node, 'raws', 'spaces', lastAdded);\n              node.raws.spaces[lastAdded].after = rawLastComment + content;\n            } else {\n              var lastValue = node[lastAdded] || '';\n              var rawLastValue = (0, _util.getProp)(node, 'raws', lastAdded) || lastValue;\n              (0, _util.ensureObject)(node, 'raws');\n              node.raws[lastAdded] = rawLastValue + content;\n            }\n          } else {\n            commentBefore = commentBefore + content;\n          }\n\n          break;\n\n        default:\n          return this.error(\"Unexpected \\\"\" + content + \"\\\" found.\", {\n            index: token[_tokenize.FIELDS.START_POS]\n          });\n      }\n\n      pos++;\n    }\n\n    unescapeProp(node, \"attribute\");\n    unescapeProp(node, \"namespace\");\n    this.newNode(new _attribute[\"default\"](node));\n    this.position++;\n  }\n  /**\n   * return a node containing meaningless garbage up to (but not including) the specified token position.\n   * if the token position is negative, all remaining tokens are consumed.\n   *\n   * This returns an array containing a single string node if all whitespace,\n   * otherwise an array of comment nodes with space before and after.\n   *\n   * These tokens are not added to the current selector, the caller can add them or use them to amend\n   * a previous node's space metadata.\n   *\n   * In lossy mode, this returns only comments.\n   */\n  ;\n\n  _proto.parseWhitespaceEquivalentTokens = function parseWhitespaceEquivalentTokens(stopPosition) {\n    if (stopPosition < 0) {\n      stopPosition = this.tokens.length;\n    }\n\n    var startPosition = this.position;\n    var nodes = [];\n    var space = \"\";\n    var lastComment = undefined;\n\n    do {\n      if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {\n        if (!this.options.lossy) {\n          space += this.content();\n        }\n      } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.comment) {\n        var spaces = {};\n\n        if (space) {\n          spaces.before = space;\n          space = \"\";\n        }\n\n        lastComment = new _comment[\"default\"]({\n          value: this.content(),\n          source: getTokenSource(this.currToken),\n          sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],\n          spaces: spaces\n        });\n        nodes.push(lastComment);\n      }\n    } while (++this.position < stopPosition);\n\n    if (space) {\n      if (lastComment) {\n        lastComment.spaces.after = space;\n      } else if (!this.options.lossy) {\n        var firstToken = this.tokens[startPosition];\n        var lastToken = this.tokens[this.position - 1];\n        nodes.push(new _string[\"default\"]({\n          value: '',\n          source: getSource(firstToken[_tokenize.FIELDS.START_LINE], firstToken[_tokenize.FIELDS.START_COL], lastToken[_tokenize.FIELDS.END_LINE], lastToken[_tokenize.FIELDS.END_COL]),\n          sourceIndex: firstToken[_tokenize.FIELDS.START_POS],\n          spaces: {\n            before: space,\n            after: ''\n          }\n        }));\n      }\n    }\n\n    return nodes;\n  }\n  /**\n   * \n   * @param {*} nodes \n   */\n  ;\n\n  _proto.convertWhitespaceNodesToSpace = function convertWhitespaceNodesToSpace(nodes, requiredSpace) {\n    var _this2 = this;\n\n    if (requiredSpace === void 0) {\n      requiredSpace = false;\n    }\n\n    var space = \"\";\n    var rawSpace = \"\";\n    nodes.forEach(function (n) {\n      var spaceBefore = _this2.lossySpace(n.spaces.before, requiredSpace);\n\n      var rawSpaceBefore = _this2.lossySpace(n.rawSpaceBefore, requiredSpace);\n\n      space += spaceBefore + _this2.lossySpace(n.spaces.after, requiredSpace && spaceBefore.length === 0);\n      rawSpace += spaceBefore + n.value + _this2.lossySpace(n.rawSpaceAfter, requiredSpace && rawSpaceBefore.length === 0);\n    });\n\n    if (rawSpace === space) {\n      rawSpace = undefined;\n    }\n\n    var result = {\n      space: space,\n      rawSpace: rawSpace\n    };\n    return result;\n  };\n\n  _proto.isNamedCombinator = function isNamedCombinator(position) {\n    if (position === void 0) {\n      position = this.position;\n    }\n\n    return this.tokens[position + 0] && this.tokens[position + 0][_tokenize.FIELDS.TYPE] === tokens.slash && this.tokens[position + 1] && this.tokens[position + 1][_tokenize.FIELDS.TYPE] === tokens.word && this.tokens[position + 2] && this.tokens[position + 2][_tokenize.FIELDS.TYPE] === tokens.slash;\n  };\n\n  _proto.namedCombinator = function namedCombinator() {\n    if (this.isNamedCombinator()) {\n      var nameRaw = this.content(this.tokens[this.position + 1]);\n      var name = (0, _util.unesc)(nameRaw).toLowerCase();\n      var raws = {};\n\n      if (name !== nameRaw) {\n        raws.value = \"/\" + nameRaw + \"/\";\n      }\n\n      var node = new _combinator[\"default\"]({\n        value: \"/\" + name + \"/\",\n        source: getSource(this.currToken[_tokenize.FIELDS.START_LINE], this.currToken[_tokenize.FIELDS.START_COL], this.tokens[this.position + 2][_tokenize.FIELDS.END_LINE], this.tokens[this.position + 2][_tokenize.FIELDS.END_COL]),\n        sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],\n        raws: raws\n      });\n      this.position = this.position + 3;\n      return node;\n    } else {\n      this.unexpected();\n    }\n  };\n\n  _proto.combinator = function combinator() {\n    var _this3 = this;\n\n    if (this.content() === '|') {\n      return this.namespace();\n    } // We need to decide between a space that's a descendant combinator and meaningless whitespace at the end of a selector.\n\n\n    var nextSigTokenPos = this.locateNextMeaningfulToken(this.position);\n\n    if (nextSigTokenPos < 0 || this.tokens[nextSigTokenPos][_tokenize.FIELDS.TYPE] === tokens.comma) {\n      var nodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);\n\n      if (nodes.length > 0) {\n        var last = this.current.last;\n\n        if (last) {\n          var _this$convertWhitespa = this.convertWhitespaceNodesToSpace(nodes),\n              space = _this$convertWhitespa.space,\n              rawSpace = _this$convertWhitespa.rawSpace;\n\n          if (rawSpace !== undefined) {\n            last.rawSpaceAfter += rawSpace;\n          }\n\n          last.spaces.after += space;\n        } else {\n          nodes.forEach(function (n) {\n            return _this3.newNode(n);\n          });\n        }\n      }\n\n      return;\n    }\n\n    var firstToken = this.currToken;\n    var spaceOrDescendantSelectorNodes = undefined;\n\n    if (nextSigTokenPos > this.position) {\n      spaceOrDescendantSelectorNodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);\n    }\n\n    var node;\n\n    if (this.isNamedCombinator()) {\n      node = this.namedCombinator();\n    } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.combinator) {\n      node = new _combinator[\"default\"]({\n        value: this.content(),\n        source: getTokenSource(this.currToken),\n        sourceIndex: this.currToken[_tokenize.FIELDS.START_POS]\n      });\n      this.position++;\n    } else if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {// pass\n    } else if (!spaceOrDescendantSelectorNodes) {\n      this.unexpected();\n    }\n\n    if (node) {\n      if (spaceOrDescendantSelectorNodes) {\n        var _this$convertWhitespa2 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes),\n            _space = _this$convertWhitespa2.space,\n            _rawSpace = _this$convertWhitespa2.rawSpace;\n\n        node.spaces.before = _space;\n        node.rawSpaceBefore = _rawSpace;\n      }\n    } else {\n      // descendant combinator\n      var _this$convertWhitespa3 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes, true),\n          _space2 = _this$convertWhitespa3.space,\n          _rawSpace2 = _this$convertWhitespa3.rawSpace;\n\n      if (!_rawSpace2) {\n        _rawSpace2 = _space2;\n      }\n\n      var spaces = {};\n      var raws = {\n        spaces: {}\n      };\n\n      if (_space2.endsWith(' ') && _rawSpace2.endsWith(' ')) {\n        spaces.before = _space2.slice(0, _space2.length - 1);\n        raws.spaces.before = _rawSpace2.slice(0, _rawSpace2.length - 1);\n      } else if (_space2.startsWith(' ') && _rawSpace2.startsWith(' ')) {\n        spaces.after = _space2.slice(1);\n        raws.spaces.after = _rawSpace2.slice(1);\n      } else {\n        raws.value = _rawSpace2;\n      }\n\n      node = new _combinator[\"default\"]({\n        value: ' ',\n        source: getTokenSourceSpan(firstToken, this.tokens[this.position - 1]),\n        sourceIndex: firstToken[_tokenize.FIELDS.START_POS],\n        spaces: spaces,\n        raws: raws\n      });\n    }\n\n    if (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.space) {\n      node.spaces.after = this.optionalSpace(this.content());\n      this.position++;\n    }\n\n    return this.newNode(node);\n  };\n\n  _proto.comma = function comma() {\n    if (this.position === this.tokens.length - 1) {\n      this.root.trailingComma = true;\n      this.position++;\n      return;\n    }\n\n    this.current._inferEndPosition();\n\n    var selector = new _selector[\"default\"]({\n      source: {\n        start: tokenStart(this.tokens[this.position + 1])\n      }\n    });\n    this.current.parent.append(selector);\n    this.current = selector;\n    this.position++;\n  };\n\n  _proto.comment = function comment() {\n    var current = this.currToken;\n    this.newNode(new _comment[\"default\"]({\n      value: this.content(),\n      source: getTokenSource(current),\n      sourceIndex: current[_tokenize.FIELDS.START_POS]\n    }));\n    this.position++;\n  };\n\n  _proto.error = function error(message, opts) {\n    throw this.root.error(message, opts);\n  };\n\n  _proto.missingBackslash = function missingBackslash() {\n    return this.error('Expected a backslash preceding the semicolon.', {\n      index: this.currToken[_tokenize.FIELDS.START_POS]\n    });\n  };\n\n  _proto.missingParenthesis = function missingParenthesis() {\n    return this.expected('opening parenthesis', this.currToken[_tokenize.FIELDS.START_POS]);\n  };\n\n  _proto.missingSquareBracket = function missingSquareBracket() {\n    return this.expected('opening square bracket', this.currToken[_tokenize.FIELDS.START_POS]);\n  };\n\n  _proto.unexpected = function unexpected() {\n    return this.error(\"Unexpected '\" + this.content() + \"'. Escaping special characters with \\\\ may help.\", this.currToken[_tokenize.FIELDS.START_POS]);\n  };\n\n  _proto.namespace = function namespace() {\n    var before = this.prevToken && this.content(this.prevToken) || true;\n\n    if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.word) {\n      this.position++;\n      return this.word(before);\n    } else if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.asterisk) {\n      this.position++;\n      return this.universal(before);\n    }\n  };\n\n  _proto.nesting = function nesting() {\n    if (this.nextToken) {\n      var nextContent = this.content(this.nextToken);\n\n      if (nextContent === \"|\") {\n        this.position++;\n        return;\n      }\n    }\n\n    var current = this.currToken;\n    this.newNode(new _nesting[\"default\"]({\n      value: this.content(),\n      source: getTokenSource(current),\n      sourceIndex: current[_tokenize.FIELDS.START_POS]\n    }));\n    this.position++;\n  };\n\n  _proto.parentheses = function parentheses() {\n    var last = this.current.last;\n    var unbalanced = 1;\n    this.position++;\n\n    if (last && last.type === types.PSEUDO) {\n      var selector = new _selector[\"default\"]({\n        source: {\n          start: tokenStart(this.tokens[this.position - 1])\n        }\n      });\n      var cache = this.current;\n      last.append(selector);\n      this.current = selector;\n\n      while (this.position < this.tokens.length && unbalanced) {\n        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {\n          unbalanced++;\n        }\n\n        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {\n          unbalanced--;\n        }\n\n        if (unbalanced) {\n          this.parse();\n        } else {\n          this.current.source.end = tokenEnd(this.currToken);\n          this.current.parent.source.end = tokenEnd(this.currToken);\n          this.position++;\n        }\n      }\n\n      this.current = cache;\n    } else {\n      // I think this case should be an error. It's used to implement a basic parse of media queries\n      // but I don't think it's a good idea.\n      var parenStart = this.currToken;\n      var parenValue = \"(\";\n      var parenEnd;\n\n      while (this.position < this.tokens.length && unbalanced) {\n        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {\n          unbalanced++;\n        }\n\n        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {\n          unbalanced--;\n        }\n\n        parenEnd = this.currToken;\n        parenValue += this.parseParenthesisToken(this.currToken);\n        this.position++;\n      }\n\n      if (last) {\n        last.appendToPropertyAndEscape(\"value\", parenValue, parenValue);\n      } else {\n        this.newNode(new _string[\"default\"]({\n          value: parenValue,\n          source: getSource(parenStart[_tokenize.FIELDS.START_LINE], parenStart[_tokenize.FIELDS.START_COL], parenEnd[_tokenize.FIELDS.END_LINE], parenEnd[_tokenize.FIELDS.END_COL]),\n          sourceIndex: parenStart[_tokenize.FIELDS.START_POS]\n        }));\n      }\n    }\n\n    if (unbalanced) {\n      return this.expected('closing parenthesis', this.currToken[_tokenize.FIELDS.START_POS]);\n    }\n  };\n\n  _proto.pseudo = function pseudo() {\n    var _this4 = this;\n\n    var pseudoStr = '';\n    var startingToken = this.currToken;\n\n    while (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.colon) {\n      pseudoStr += this.content();\n      this.position++;\n    }\n\n    if (!this.currToken) {\n      return this.expected(['pseudo-class', 'pseudo-element'], this.position - 1);\n    }\n\n    if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.word) {\n      this.splitWord(false, function (first, length) {\n        pseudoStr += first;\n\n        _this4.newNode(new _pseudo[\"default\"]({\n          value: pseudoStr,\n          source: getTokenSourceSpan(startingToken, _this4.currToken),\n          sourceIndex: startingToken[_tokenize.FIELDS.START_POS]\n        }));\n\n        if (length > 1 && _this4.nextToken && _this4.nextToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {\n          _this4.error('Misplaced parenthesis.', {\n            index: _this4.nextToken[_tokenize.FIELDS.START_POS]\n          });\n        }\n      });\n    } else {\n      return this.expected(['pseudo-class', 'pseudo-element'], this.currToken[_tokenize.FIELDS.START_POS]);\n    }\n  };\n\n  _proto.space = function space() {\n    var content = this.content(); // Handle space before and after the selector\n\n    if (this.position === 0 || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis || this.current.nodes.every(function (node) {\n      return node.type === 'comment';\n    })) {\n      this.spaces = this.optionalSpace(content);\n      this.position++;\n    } else if (this.position === this.tokens.length - 1 || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {\n      this.current.last.spaces.after = this.optionalSpace(content);\n      this.position++;\n    } else {\n      this.combinator();\n    }\n  };\n\n  _proto.string = function string() {\n    var current = this.currToken;\n    this.newNode(new _string[\"default\"]({\n      value: this.content(),\n      source: getTokenSource(current),\n      sourceIndex: current[_tokenize.FIELDS.START_POS]\n    }));\n    this.position++;\n  };\n\n  _proto.universal = function universal(namespace) {\n    var nextToken = this.nextToken;\n\n    if (nextToken && this.content(nextToken) === '|') {\n      this.position++;\n      return this.namespace();\n    }\n\n    var current = this.currToken;\n    this.newNode(new _universal[\"default\"]({\n      value: this.content(),\n      source: getTokenSource(current),\n      sourceIndex: current[_tokenize.FIELDS.START_POS]\n    }), namespace);\n    this.position++;\n  };\n\n  _proto.splitWord = function splitWord(namespace, firstCallback) {\n    var _this5 = this;\n\n    var nextToken = this.nextToken;\n    var word = this.content();\n\n    while (nextToken && ~[tokens.dollar, tokens.caret, tokens.equals, tokens.word].indexOf(nextToken[_tokenize.FIELDS.TYPE])) {\n      this.position++;\n      var current = this.content();\n      word += current;\n\n      if (current.lastIndexOf('\\\\') === current.length - 1) {\n        var next = this.nextToken;\n\n        if (next && next[_tokenize.FIELDS.TYPE] === tokens.space) {\n          word += this.requiredSpace(this.content(next));\n          this.position++;\n        }\n      }\n\n      nextToken = this.nextToken;\n    }\n\n    var hasClass = indexesOf(word, '.').filter(function (i) {\n      // Allow escaped dot within class name\n      var escapedDot = word[i - 1] === '\\\\'; // Allow decimal numbers percent in @keyframes\n\n      var isKeyframesPercent = /^\\d+\\.\\d+%$/.test(word);\n      return !escapedDot && !isKeyframesPercent;\n    });\n    var hasId = indexesOf(word, '#').filter(function (i) {\n      return word[i - 1] !== '\\\\';\n    }); // Eliminate Sass interpolations from the list of id indexes\n\n    var interpolations = indexesOf(word, '#{');\n\n    if (interpolations.length) {\n      hasId = hasId.filter(function (hashIndex) {\n        return !~interpolations.indexOf(hashIndex);\n      });\n    }\n\n    var indices = (0, _sortAscending[\"default\"])(uniqs([0].concat(hasClass, hasId)));\n    indices.forEach(function (ind, i) {\n      var index = indices[i + 1] || word.length;\n      var value = word.slice(ind, index);\n\n      if (i === 0 && firstCallback) {\n        return firstCallback.call(_this5, value, indices.length);\n      }\n\n      var node;\n      var current = _this5.currToken;\n      var sourceIndex = current[_tokenize.FIELDS.START_POS] + indices[i];\n      var source = getSource(current[1], current[2] + ind, current[3], current[2] + (index - 1));\n\n      if (~hasClass.indexOf(ind)) {\n        var classNameOpts = {\n          value: value.slice(1),\n          source: source,\n          sourceIndex: sourceIndex\n        };\n        node = new _className[\"default\"](unescapeProp(classNameOpts, \"value\"));\n      } else if (~hasId.indexOf(ind)) {\n        var idOpts = {\n          value: value.slice(1),\n          source: source,\n          sourceIndex: sourceIndex\n        };\n        node = new _id[\"default\"](unescapeProp(idOpts, \"value\"));\n      } else {\n        var tagOpts = {\n          value: value,\n          source: source,\n          sourceIndex: sourceIndex\n        };\n        unescapeProp(tagOpts, \"value\");\n        node = new _tag[\"default\"](tagOpts);\n      }\n\n      _this5.newNode(node, namespace); // Ensure that the namespace is used only once\n\n\n      namespace = null;\n    });\n    this.position++;\n  };\n\n  _proto.word = function word(namespace) {\n    var nextToken = this.nextToken;\n\n    if (nextToken && this.content(nextToken) === '|') {\n      this.position++;\n      return this.namespace();\n    }\n\n    return this.splitWord(namespace);\n  };\n\n  _proto.loop = function loop() {\n    while (this.position < this.tokens.length) {\n      this.parse(true);\n    }\n\n    this.current._inferEndPosition();\n\n    return this.root;\n  };\n\n  _proto.parse = function parse(throwOnParenthesis) {\n    switch (this.currToken[_tokenize.FIELDS.TYPE]) {\n      case tokens.space:\n        this.space();\n        break;\n\n      case tokens.comment:\n        this.comment();\n        break;\n\n      case tokens.openParenthesis:\n        this.parentheses();\n        break;\n\n      case tokens.closeParenthesis:\n        if (throwOnParenthesis) {\n          this.missingParenthesis();\n        }\n\n        break;\n\n      case tokens.openSquare:\n        this.attribute();\n        break;\n\n      case tokens.dollar:\n      case tokens.caret:\n      case tokens.equals:\n      case tokens.word:\n        this.word();\n        break;\n\n      case tokens.colon:\n        this.pseudo();\n        break;\n\n      case tokens.comma:\n        this.comma();\n        break;\n\n      case tokens.asterisk:\n        this.universal();\n        break;\n\n      case tokens.ampersand:\n        this.nesting();\n        break;\n\n      case tokens.slash:\n      case tokens.combinator:\n        this.combinator();\n        break;\n\n      case tokens.str:\n        this.string();\n        break;\n      // These cases throw; no break needed.\n\n      case tokens.closeSquare:\n        this.missingSquareBracket();\n\n      case tokens.semicolon:\n        this.missingBackslash();\n\n      default:\n        this.unexpected();\n    }\n  }\n  /**\n   * Helpers\n   */\n  ;\n\n  _proto.expected = function expected(description, index, found) {\n    if (Array.isArray(description)) {\n      var last = description.pop();\n      description = description.join(', ') + \" or \" + last;\n    }\n\n    var an = /^[aeiou]/.test(description[0]) ? 'an' : 'a';\n\n    if (!found) {\n      return this.error(\"Expected \" + an + \" \" + description + \".\", {\n        index: index\n      });\n    }\n\n    return this.error(\"Expected \" + an + \" \" + description + \", found \\\"\" + found + \"\\\" instead.\", {\n      index: index\n    });\n  };\n\n  _proto.requiredSpace = function requiredSpace(space) {\n    return this.options.lossy ? ' ' : space;\n  };\n\n  _proto.optionalSpace = function optionalSpace(space) {\n    return this.options.lossy ? '' : space;\n  };\n\n  _proto.lossySpace = function lossySpace(space, required) {\n    if (this.options.lossy) {\n      return required ? ' ' : '';\n    } else {\n      return space;\n    }\n  };\n\n  _proto.parseParenthesisToken = function parseParenthesisToken(token) {\n    var content = this.content(token);\n\n    if (token[_tokenize.FIELDS.TYPE] === tokens.space) {\n      return this.requiredSpace(content);\n    } else {\n      return content;\n    }\n  };\n\n  _proto.newNode = function newNode(node, namespace) {\n    if (namespace) {\n      if (/^ +$/.test(namespace)) {\n        if (!this.options.lossy) {\n          this.spaces = (this.spaces || '') + namespace;\n        }\n\n        namespace = true;\n      }\n\n      node.namespace = namespace;\n      unescapeProp(node, \"namespace\");\n    }\n\n    if (this.spaces) {\n      node.spaces.before = this.spaces;\n      this.spaces = '';\n    }\n\n    return this.current.append(node);\n  };\n\n  _proto.content = function content(token) {\n    if (token === void 0) {\n      token = this.currToken;\n    }\n\n    return this.css.slice(token[_tokenize.FIELDS.START_POS], token[_tokenize.FIELDS.END_POS]);\n  };\n\n  /**\n   * returns the index of the next non-whitespace, non-comment token.\n   * returns -1 if no meaningful token is found.\n   */\n  _proto.locateNextMeaningfulToken = function locateNextMeaningfulToken(startPosition) {\n    if (startPosition === void 0) {\n      startPosition = this.position + 1;\n    }\n\n    var searchPosition = startPosition;\n\n    while (searchPosition < this.tokens.length) {\n      if (WHITESPACE_EQUIV_TOKENS[this.tokens[searchPosition][_tokenize.FIELDS.TYPE]]) {\n        searchPosition++;\n        continue;\n      } else {\n        return searchPosition;\n      }\n    }\n\n    return -1;\n  };\n\n  _createClass(Parser, [{\n    key: \"currToken\",\n    get: function get() {\n      return this.tokens[this.position];\n    }\n  }, {\n    key: \"nextToken\",\n    get: function get() {\n      return this.tokens[this.position + 1];\n    }\n  }, {\n    key: \"prevToken\",\n    get: function get() {\n      return this.tokens[this.position - 1];\n    }\n  }]);\n\n  return Parser;\n}();\n\nexports[\"default\"] = Parser;\nmodule.exports = exports.default;"],"mappings":"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"},"metadata":{},"sourceType":"script"}