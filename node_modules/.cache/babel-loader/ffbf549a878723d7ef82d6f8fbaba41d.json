{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports[\"default\"] = tokenize;\nexports.FIELDS = void 0;\nvar t = _interopRequireWildcard(require(\"./tokenTypes\"));\nvar _unescapable, _wordDelimiters;\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n  _getRequireWildcardCache = function _getRequireWildcardCache() {\n    return cache;\n  };\n  return cache;\n}\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      \"default\": obj\n    };\n  }\n  var cache = _getRequireWildcardCache();\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj[\"default\"] = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\nvar unescapable = (_unescapable = {}, _unescapable[t.tab] = true, _unescapable[t.newline] = true, _unescapable[t.cr] = true, _unescapable[t.feed] = true, _unescapable);\nvar wordDelimiters = (_wordDelimiters = {}, _wordDelimiters[t.space] = true, _wordDelimiters[t.tab] = true, _wordDelimiters[t.newline] = true, _wordDelimiters[t.cr] = true, _wordDelimiters[t.feed] = true, _wordDelimiters[t.ampersand] = true, _wordDelimiters[t.asterisk] = true, _wordDelimiters[t.bang] = true, _wordDelimiters[t.comma] = true, _wordDelimiters[t.colon] = true, _wordDelimiters[t.semicolon] = true, _wordDelimiters[t.openParenthesis] = true, _wordDelimiters[t.closeParenthesis] = true, _wordDelimiters[t.openSquare] = true, _wordDelimiters[t.closeSquare] = true, _wordDelimiters[t.singleQuote] = true, _wordDelimiters[t.doubleQuote] = true, _wordDelimiters[t.plus] = true, _wordDelimiters[t.pipe] = true, _wordDelimiters[t.tilde] = true, _wordDelimiters[t.greaterThan] = true, _wordDelimiters[t.equals] = true, _wordDelimiters[t.dollar] = true, _wordDelimiters[t.caret] = true, _wordDelimiters[t.slash] = true, _wordDelimiters);\nvar hex = {};\nvar hexChars = \"0123456789abcdefABCDEF\";\nfor (var i = 0; i < hexChars.length; i++) {\n  hex[hexChars.charCodeAt(i)] = true;\n}\n/**\n *  Returns the last index of the bar css word\n * @param {string} css The string in which the word begins\n * @param {number} start The index into the string where word's first letter occurs\n */\n\nfunction consumeWord(css, start) {\n  var next = start;\n  var code;\n  do {\n    code = css.charCodeAt(next);\n    if (wordDelimiters[code]) {\n      return next - 1;\n    } else if (code === t.backslash) {\n      next = consumeEscape(css, next) + 1;\n    } else {\n      // All other characters are part of the word\n      next++;\n    }\n  } while (next < css.length);\n  return next - 1;\n}\n/**\n *  Returns the last index of the escape sequence\n * @param {string} css The string in which the sequence begins\n * @param {number} start The index into the string where escape character (`\\`) occurs.\n */\n\nfunction consumeEscape(css, start) {\n  var next = start;\n  var code = css.charCodeAt(next + 1);\n  if (unescapable[code]) {// just consume the escape char\n  } else if (hex[code]) {\n    var hexDigits = 0; // consume up to 6 hex chars\n\n    do {\n      next++;\n      hexDigits++;\n      code = css.charCodeAt(next + 1);\n    } while (hex[code] && hexDigits < 6); // if fewer than 6 hex chars, a trailing space ends the escape\n\n    if (hexDigits < 6 && code === t.space) {\n      next++;\n    }\n  } else {\n    // the next char is part of the current word\n    next++;\n  }\n  return next;\n}\nvar FIELDS = {\n  TYPE: 0,\n  START_LINE: 1,\n  START_COL: 2,\n  END_LINE: 3,\n  END_COL: 4,\n  START_POS: 5,\n  END_POS: 6\n};\nexports.FIELDS = FIELDS;\nfunction tokenize(input) {\n  var tokens = [];\n  var css = input.css.valueOf();\n  var _css = css,\n    length = _css.length;\n  var offset = -1;\n  var line = 1;\n  var start = 0;\n  var end = 0;\n  var code, content, endColumn, endLine, escaped, escapePos, last, lines, next, nextLine, nextOffset, quote, tokenType;\n  function unclosed(what, fix) {\n    if (input.safe) {\n      // fyi: this is never set to true.\n      css += fix;\n      next = css.length - 1;\n    } else {\n      throw input.error('Unclosed ' + what, line, start - offset, start);\n    }\n  }\n  while (start < length) {\n    code = css.charCodeAt(start);\n    if (code === t.newline) {\n      offset = start;\n      line += 1;\n    }\n    switch (code) {\n      case t.space:\n      case t.tab:\n      case t.newline:\n      case t.cr:\n      case t.feed:\n        next = start;\n        do {\n          next += 1;\n          code = css.charCodeAt(next);\n          if (code === t.newline) {\n            offset = next;\n            line += 1;\n          }\n        } while (code === t.space || code === t.newline || code === t.tab || code === t.cr || code === t.feed);\n        tokenType = t.space;\n        endLine = line;\n        endColumn = next - offset - 1;\n        end = next;\n        break;\n      case t.plus:\n      case t.greaterThan:\n      case t.tilde:\n      case t.pipe:\n        next = start;\n        do {\n          next += 1;\n          code = css.charCodeAt(next);\n        } while (code === t.plus || code === t.greaterThan || code === t.tilde || code === t.pipe);\n        tokenType = t.combinator;\n        endLine = line;\n        endColumn = start - offset;\n        end = next;\n        break;\n      // Consume these characters as single tokens.\n\n      case t.asterisk:\n      case t.ampersand:\n      case t.bang:\n      case t.comma:\n      case t.equals:\n      case t.dollar:\n      case t.caret:\n      case t.openSquare:\n      case t.closeSquare:\n      case t.colon:\n      case t.semicolon:\n      case t.openParenthesis:\n      case t.closeParenthesis:\n        next = start;\n        tokenType = code;\n        endLine = line;\n        endColumn = start - offset;\n        end = next + 1;\n        break;\n      case t.singleQuote:\n      case t.doubleQuote:\n        quote = code === t.singleQuote ? \"'\" : '\"';\n        next = start;\n        do {\n          escaped = false;\n          next = css.indexOf(quote, next + 1);\n          if (next === -1) {\n            unclosed('quote', quote);\n          }\n          escapePos = next;\n          while (css.charCodeAt(escapePos - 1) === t.backslash) {\n            escapePos -= 1;\n            escaped = !escaped;\n          }\n        } while (escaped);\n        tokenType = t.str;\n        endLine = line;\n        endColumn = start - offset;\n        end = next + 1;\n        break;\n      default:\n        if (code === t.slash && css.charCodeAt(start + 1) === t.asterisk) {\n          next = css.indexOf('*/', start + 2) + 1;\n          if (next === 0) {\n            unclosed('comment', '*/');\n          }\n          content = css.slice(start, next + 1);\n          lines = content.split('\\n');\n          last = lines.length - 1;\n          if (last > 0) {\n            nextLine = line + last;\n            nextOffset = next - lines[last].length;\n          } else {\n            nextLine = line;\n            nextOffset = offset;\n          }\n          tokenType = t.comment;\n          line = nextLine;\n          endLine = nextLine;\n          endColumn = next - nextOffset;\n        } else if (code === t.slash) {\n          next = start;\n          tokenType = code;\n          endLine = line;\n          endColumn = start - offset;\n          end = next + 1;\n        } else {\n          next = consumeWord(css, start);\n          tokenType = t.word;\n          endLine = line;\n          endColumn = next - offset;\n        }\n        end = next + 1;\n        break;\n    } // Ensure that the token structure remains consistent\n\n    tokens.push([tokenType,\n    // [0] Token type\n    line,\n    // [1] Starting line\n    start - offset,\n    // [2] Starting column\n    endLine,\n    // [3] Ending line\n    endColumn,\n    // [4] Ending column\n    start,\n    // [5] Start position / Source index\n    end // [6] End position\n    ]); // Reset offset for the next token\n\n    if (nextOffset) {\n      offset = nextOffset;\n      nextOffset = null;\n    }\n    start = end;\n  }\n  return tokens;\n}","map":{"version":3,"names":["exports","__esModule","tokenize","FIELDS","t","_interopRequireWildcard","require","_unescapable","_wordDelimiters","_getRequireWildcardCache","WeakMap","cache","obj","has","get","newObj","hasPropertyDescriptor","Object","defineProperty","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","unescapable","tab","newline","cr","feed","wordDelimiters","space","ampersand","asterisk","bang","comma","colon","semicolon","openParenthesis","closeParenthesis","openSquare","closeSquare","singleQuote","doubleQuote","plus","pipe","tilde","greaterThan","equals","dollar","caret","slash","hex","hexChars","i","length","charCodeAt","consumeWord","css","start","next","code","backslash","consumeEscape","hexDigits","TYPE","START_LINE","START_COL","END_LINE","END_COL","START_POS","END_POS","input","tokens","valueOf","_css","offset","line","end","content","endColumn","endLine","escaped","escapePos","last","lines","nextLine","nextOffset","quote","tokenType","unclosed","what","fix","safe","error","combinator","indexOf","str","slice","split","comment","word","push"],"sources":["D:/MyFile/Project/shop-via/node_modules/postcss-selector-parser/dist/tokenize.js"],"sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\nexports[\"default\"] = tokenize;\nexports.FIELDS = void 0;\n\nvar t = _interopRequireWildcard(require(\"./tokenTypes\"));\n\nvar _unescapable, _wordDelimiters;\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { \"default\": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj[\"default\"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nvar unescapable = (_unescapable = {}, _unescapable[t.tab] = true, _unescapable[t.newline] = true, _unescapable[t.cr] = true, _unescapable[t.feed] = true, _unescapable);\nvar wordDelimiters = (_wordDelimiters = {}, _wordDelimiters[t.space] = true, _wordDelimiters[t.tab] = true, _wordDelimiters[t.newline] = true, _wordDelimiters[t.cr] = true, _wordDelimiters[t.feed] = true, _wordDelimiters[t.ampersand] = true, _wordDelimiters[t.asterisk] = true, _wordDelimiters[t.bang] = true, _wordDelimiters[t.comma] = true, _wordDelimiters[t.colon] = true, _wordDelimiters[t.semicolon] = true, _wordDelimiters[t.openParenthesis] = true, _wordDelimiters[t.closeParenthesis] = true, _wordDelimiters[t.openSquare] = true, _wordDelimiters[t.closeSquare] = true, _wordDelimiters[t.singleQuote] = true, _wordDelimiters[t.doubleQuote] = true, _wordDelimiters[t.plus] = true, _wordDelimiters[t.pipe] = true, _wordDelimiters[t.tilde] = true, _wordDelimiters[t.greaterThan] = true, _wordDelimiters[t.equals] = true, _wordDelimiters[t.dollar] = true, _wordDelimiters[t.caret] = true, _wordDelimiters[t.slash] = true, _wordDelimiters);\nvar hex = {};\nvar hexChars = \"0123456789abcdefABCDEF\";\n\nfor (var i = 0; i < hexChars.length; i++) {\n  hex[hexChars.charCodeAt(i)] = true;\n}\n/**\n *  Returns the last index of the bar css word\n * @param {string} css The string in which the word begins\n * @param {number} start The index into the string where word's first letter occurs\n */\n\n\nfunction consumeWord(css, start) {\n  var next = start;\n  var code;\n\n  do {\n    code = css.charCodeAt(next);\n\n    if (wordDelimiters[code]) {\n      return next - 1;\n    } else if (code === t.backslash) {\n      next = consumeEscape(css, next) + 1;\n    } else {\n      // All other characters are part of the word\n      next++;\n    }\n  } while (next < css.length);\n\n  return next - 1;\n}\n/**\n *  Returns the last index of the escape sequence\n * @param {string} css The string in which the sequence begins\n * @param {number} start The index into the string where escape character (`\\`) occurs.\n */\n\n\nfunction consumeEscape(css, start) {\n  var next = start;\n  var code = css.charCodeAt(next + 1);\n\n  if (unescapable[code]) {// just consume the escape char\n  } else if (hex[code]) {\n    var hexDigits = 0; // consume up to 6 hex chars\n\n    do {\n      next++;\n      hexDigits++;\n      code = css.charCodeAt(next + 1);\n    } while (hex[code] && hexDigits < 6); // if fewer than 6 hex chars, a trailing space ends the escape\n\n\n    if (hexDigits < 6 && code === t.space) {\n      next++;\n    }\n  } else {\n    // the next char is part of the current word\n    next++;\n  }\n\n  return next;\n}\n\nvar FIELDS = {\n  TYPE: 0,\n  START_LINE: 1,\n  START_COL: 2,\n  END_LINE: 3,\n  END_COL: 4,\n  START_POS: 5,\n  END_POS: 6\n};\nexports.FIELDS = FIELDS;\n\nfunction tokenize(input) {\n  var tokens = [];\n  var css = input.css.valueOf();\n  var _css = css,\n      length = _css.length;\n  var offset = -1;\n  var line = 1;\n  var start = 0;\n  var end = 0;\n  var code, content, endColumn, endLine, escaped, escapePos, last, lines, next, nextLine, nextOffset, quote, tokenType;\n\n  function unclosed(what, fix) {\n    if (input.safe) {\n      // fyi: this is never set to true.\n      css += fix;\n      next = css.length - 1;\n    } else {\n      throw input.error('Unclosed ' + what, line, start - offset, start);\n    }\n  }\n\n  while (start < length) {\n    code = css.charCodeAt(start);\n\n    if (code === t.newline) {\n      offset = start;\n      line += 1;\n    }\n\n    switch (code) {\n      case t.space:\n      case t.tab:\n      case t.newline:\n      case t.cr:\n      case t.feed:\n        next = start;\n\n        do {\n          next += 1;\n          code = css.charCodeAt(next);\n\n          if (code === t.newline) {\n            offset = next;\n            line += 1;\n          }\n        } while (code === t.space || code === t.newline || code === t.tab || code === t.cr || code === t.feed);\n\n        tokenType = t.space;\n        endLine = line;\n        endColumn = next - offset - 1;\n        end = next;\n        break;\n\n      case t.plus:\n      case t.greaterThan:\n      case t.tilde:\n      case t.pipe:\n        next = start;\n\n        do {\n          next += 1;\n          code = css.charCodeAt(next);\n        } while (code === t.plus || code === t.greaterThan || code === t.tilde || code === t.pipe);\n\n        tokenType = t.combinator;\n        endLine = line;\n        endColumn = start - offset;\n        end = next;\n        break;\n      // Consume these characters as single tokens.\n\n      case t.asterisk:\n      case t.ampersand:\n      case t.bang:\n      case t.comma:\n      case t.equals:\n      case t.dollar:\n      case t.caret:\n      case t.openSquare:\n      case t.closeSquare:\n      case t.colon:\n      case t.semicolon:\n      case t.openParenthesis:\n      case t.closeParenthesis:\n        next = start;\n        tokenType = code;\n        endLine = line;\n        endColumn = start - offset;\n        end = next + 1;\n        break;\n\n      case t.singleQuote:\n      case t.doubleQuote:\n        quote = code === t.singleQuote ? \"'\" : '\"';\n        next = start;\n\n        do {\n          escaped = false;\n          next = css.indexOf(quote, next + 1);\n\n          if (next === -1) {\n            unclosed('quote', quote);\n          }\n\n          escapePos = next;\n\n          while (css.charCodeAt(escapePos - 1) === t.backslash) {\n            escapePos -= 1;\n            escaped = !escaped;\n          }\n        } while (escaped);\n\n        tokenType = t.str;\n        endLine = line;\n        endColumn = start - offset;\n        end = next + 1;\n        break;\n\n      default:\n        if (code === t.slash && css.charCodeAt(start + 1) === t.asterisk) {\n          next = css.indexOf('*/', start + 2) + 1;\n\n          if (next === 0) {\n            unclosed('comment', '*/');\n          }\n\n          content = css.slice(start, next + 1);\n          lines = content.split('\\n');\n          last = lines.length - 1;\n\n          if (last > 0) {\n            nextLine = line + last;\n            nextOffset = next - lines[last].length;\n          } else {\n            nextLine = line;\n            nextOffset = offset;\n          }\n\n          tokenType = t.comment;\n          line = nextLine;\n          endLine = nextLine;\n          endColumn = next - nextOffset;\n        } else if (code === t.slash) {\n          next = start;\n          tokenType = code;\n          endLine = line;\n          endColumn = start - offset;\n          end = next + 1;\n        } else {\n          next = consumeWord(css, start);\n          tokenType = t.word;\n          endLine = line;\n          endColumn = next - offset;\n        }\n\n        end = next + 1;\n        break;\n    } // Ensure that the token structure remains consistent\n\n\n    tokens.push([tokenType, // [0] Token type\n    line, // [1] Starting line\n    start - offset, // [2] Starting column\n    endLine, // [3] Ending line\n    endColumn, // [4] Ending column\n    start, // [5] Start position / Source index\n    end // [6] End position\n    ]); // Reset offset for the next token\n\n    if (nextOffset) {\n      offset = nextOffset;\n      nextOffset = null;\n    }\n\n    start = end;\n  }\n\n  return tokens;\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}